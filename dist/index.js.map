{
  "version": 3,
  "sources": ["../src/cache-store.ts", "../src/cache-proxy.ts", "../src/file-cache-store.ts", "../src/mem-cache-store.ts", "../src/amemo.ts"],
  "sourcesContent": ["export interface CacheStore {\n  get(key: string, expire: number): unknown;\n  set(key: string, value: unknown): void;\n  save(): void;\n}\n\nexport type Entry = {\n  timestamp: number;\n  value: unknown;\n};\n\nexport const NotFound = Symbol(\"NotFound\");\n\nexport const SECOND = 1000;\nexport const MINUTE = 60 * SECOND;\nexport const HOUR = 60 * MINUTE;\nexport const DAY = 24 * HOUR;\nexport const WEEK = 7 * DAY;\n", "import { CacheStore, DAY, NotFound } from \"./cache-store\";\nimport { FileCacheStore } from \"./file-cache-store\";\n\nexport type CacheProxyOpts = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onHit?: (key: string, args: any[]) => void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onMiss?: (key: string, args: any[]) => void;\n  // Default expiration time in milliseconds\n  defaultExpire?: number;\n  // Expiration time per property path\n  pathExpire?: Record<string, number>;\n  cacheStore?: CacheStore;\n};\n\ntype ProxyCache<T> = Record<string, T>;\n\nexport function createProxy<T extends object>(\n  api: T,\n  cache: CacheStore,\n  opts: CacheProxyOpts,\n  proxyCache: ProxyCache<T>,\n  wrapperCache: Record<string, unknown>,\n  path = \"\",\n): T {\n  if (proxyCache[path]) {\n    return proxyCache[path];\n  }\n\n  const proxy = new Proxy(api, {\n    get(target, prop /*, receiver*/) {\n      const currentPath = path + \"/\" + prop.toString();\n      const p = target[prop as keyof T];\n      if (typeof p === \"function\") {\n        if (wrapperCache[currentPath]) {\n          return wrapperCache[currentPath];\n        }\n        const bound = p.bind(target);\n        const {\n          defaultExpire = 1 * DAY,\n          pathExpire = {},\n          onHit = () => {},\n          onMiss = () => {},\n        } = opts;\n        const expire = pathExpire[currentPath] ?? defaultExpire;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const wrapped = function (...args: any[]) {\n          const key = currentPath + \": \" + JSON.stringify(args);\n          const cached = cache.get(key, expire);\n          if (cached !== NotFound) {\n            onHit(key, args);\n            return cached;\n          }\n\n          const result = bound(...args);\n          cache.set(key, result);\n          onMiss(key, args);\n          return result;\n        };\n        wrapperCache[currentPath] = wrapped;\n        return wrapped;\n      }\n\n      if (!(p instanceof Object)) {\n        return p;\n      }\n      return createProxy(\n        target[prop as keyof T] as object,\n        cache,\n        opts,\n        proxyCache,\n        wrapperCache,\n        currentPath,\n      );\n    },\n  });\n  proxyCache[path] = proxy;\n  return proxy;\n}\n", "import * as fs from \"fs\";\nimport * as path from \"path\";\n\nimport { MemCacheStore } from \"./mem-cache-store\";\n\nexport type FileCacheStoreOpts = {\n  path?: string;\n  autoSave?: boolean;\n};\n\nexport class FileCacheStore extends MemCacheStore {\n  public readonly cacheFile: string;\n  private readonly autoSave: boolean;\n  constructor(public readonly opts: FileCacheStoreOpts = {}) {\n    super();\n    this.cacheFile = opts.path ?? \".amemo.json\";\n    this.autoSave = opts.autoSave ?? true;\n    try {\n      if (!fs.existsSync(this.cacheFile)) {\n        return;\n      }\n      const data = fs.readFileSync(this.cacheFile, \"utf8\");\n      super.cache = JSON.parse(data);\n    } catch (e) {\n      // ignore\n    }\n  }\n\n  set(key: string, value: unknown) {\n    super.set(key, value);\n    if (this.autoSave) {\n      this.save();\n    }\n  }\n\n  async save() {\n    for (const [key, entry] of Object.entries(this.cache)) {\n      if (entry.value instanceof Promise) {\n        this.cache[key].value = await entry.value;\n      }\n    }\n\n    fs.mkdirSync(path.dirname(this.cacheFile), { recursive: true });\n    fs.writeFileSync(this.cacheFile, JSON.stringify(this.cache));\n  }\n}\n", "import { CacheStore, Entry, NotFound } from \"./cache-store\";\n\nexport class MemCacheStore implements CacheStore {\n  constructor(protected cache: Record<string, Entry> = {}) {}\n\n  get(key: string, expire: number) {\n    const entry = this.cache[key];\n    if (!entry) {\n      return NotFound;\n    }\n    if (Date.now() - entry.timestamp > expire) {\n      return NotFound;\n    }\n    return entry.value;\n  }\n\n  set(key: string, value: unknown) {\n    this.cache[key] = {\n      timestamp: Date.now(),\n      value,\n    };\n  }\n\n  save() {}\n}\n", "import { CacheProxyOpts, createProxy } from \"./cache-proxy\";\nimport { FileCacheStore } from \"./file-cache-store\";\n\nexport function amemo<T extends object>(api: T, opts: CacheProxyOpts = {}): T {\n  const { cacheStore = new FileCacheStore() } = opts;\n  return createProxy(api, cacheStore, opts, {}, {});\n}\n\nexport * from \"./cache-store\";\nexport * from \"./mem-cache-store\";\nexport * from \"./file-cache-store\";\nexport * from \"./cache-proxy\";\n"],
  "mappings": "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",
  "names": ["NotFound", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "createProxy", "api", "cache", "opts", "proxyCache", "wrapperCache", "path", "proxy", "target", "prop", "currentPath", "p", "bound", "defaultExpire", "DAY", "pathExpire", "onHit", "onMiss", "expire", "wrapped", "args", "key", "cached", "NotFound", "result", "fs", "path", "MemCacheStore", "cache", "key", "expire", "entry", "NotFound", "value", "FileCacheStore", "MemCacheStore", "opts", "data", "key", "value", "entry", "amemo", "api", "opts", "cacheStore", "FileCacheStore", "createProxy"]
}
